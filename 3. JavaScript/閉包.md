# closure in JS

## 簡單說明

是一個屬於函數特殊的執行環境 (scope; context)，這「封閉」的環境中保存 (record) 了讓函數可以持續 (甚至在 function 被 return 後) 存取的獨立自由變數 (free variable)。

換句話說，closure 是讓函數能「記得」被建立時的環境的一種機制。

## 作用域說明

JavaScrip 的變量作用域有兩個：**全局變量**與**局部變量**

作用域說明 example:

```javascript
var globalScope="global scope"; 
function f{ 
    var localScope="local scope"; 
    console.log(globalScope); // global scope 
}
console.log(localScope); // undefined
```

## 閉包 example 

### 如何建立閉包
> 從一個 function return 另一個 nested function 就可以建立一個 closure 環境。

例如：
```javascript 

function makeFunc() {
    // 一個局部變數
    var name = 'Fooish';

    function displayName() {
        // 內部函數可以存取外部函數的變數
        alert(name);
    }

    // 返回一個內部函數，並創建一個 closure  
    return displayName;
}

var myFunc = makeFunc();

// 顯示 Fooish
myFunc();
```
makeFunc() 執行時返回一個 function，同時自動創建了一個 closure 環境。closure 像是一個特殊的物件 (指定給了 myFunc)，closure 中包含一個函數 (displayName)，以及函數 (makeFunc) 執行當時的環境，讓你在函數返回後還是可以持續存取 closure 保存的環境 (像是能存取 name 變數，name 變數不會因為函數返回後而被刪除)。

而每一個 closure 中保存的都是一個獨立的環境。

## 另一個範例

```javascript

function f{
    var localScope="local scope";
    return function{
        console.log(localScope);
    }
}

f; // local scope
```

我們在函數 f 外訪問到了局部變量 localScope，這裡在函數 f 內定義的匿名函數就是一個閉包！

這裡兩個圓括號是什麼意思呢？我們可以簡單理解成執行兩次f，執行一次得到function{console.log(localScope);}，再執行一次相當於執行這個匿名函數。


## 資料來源與參考
[JavaScript Function Closure (閉包)](http://www.fooish.com/javascript/function-closure.html)

[閉包(Closure)的基本概念]x(http://www.victsao.com/blog/81-javascript/301-javascript-function-closure)







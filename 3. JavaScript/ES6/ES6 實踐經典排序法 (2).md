# ES6 實踐經典排序法 (2)

## 產生隨機測試陣列

為了測試排序結果，
需要每次產生一個隨機陣列

```javascript
// 產生 min 到 max 間的亂數，包含 min, max
const getRandomNum = (min, max) => {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

// 產生長度為 length 的隨機陣列
const getTestArr = ({ length = 10, min = 0, max = 10 }) => {
  let arr = [];
  for (let i = 0; i < length; i++) {
    arr.push(getRandomNum(min, max));
  }
  return arr;
};

// 產生一個 10項，每項為 0~100 的 array
const testArr = getTestArr({ max: 100 });
```

## 排序過程動畫

視覺化解釋排序法：[VisuAlgo - Sorting (Bubble, Selection, Insertion, Merge, Quick, Counting, Radix)](https://visualgo.net/en/sorting)

## 經典的排序法

參考 [一起用 JavaScript 來複習經典排序法吧！](http://huli.logdown.com/posts/2223627-review-the-classical-sort-algorithm-with-javascript)，
試著自己實做出這些排序法。

以下的範例程式碼，
可以直接貼到瀏覽器 console 中看結果

### 合併排序法（Merge Sort）

![img](/home/newtchen/Documents/MyProjects/git-notebook/source/img/merge.png)

來源：http://www.java2novice.com/java-sorting-algorithms/merge-sort/

```javascript
const mergeSort = arr => {
    /**
     * 將兩個 sorted array 合成一個 sorted array
     *
     * 這個 function 先提出來寫好，
     * 便於釐清後面 mergeSort 的主體邏輯
     */
    const getMergedSortedArr = (arr1, arr2) => {
        const clone1 = [...arr1];
        const clone2 = [...arr2];

        // 兩個 array 依序拿出第一個來比大小，
        // 小的就先放進最終的 mergedArr 中
        const finalArr = [];
        while (clone1.length > 0 && clone2.length > 0) {
            if (clone1[0] < clone2[0]) {
                finalArr.push(clone1.shift());
            } else {
                finalArr.push(clone2.shift());
            }
        }
        // 執行到這裡代表 clone1, clone2 一個空了，一個沒空
        // 所以我們要找出沒空那一個 array，
        // 並把它剩下的數字全部填到 mergedArr 最後
        const isClone1Empty = clone1.length === 0;
        (isClone1Empty ? clone2 : clone1).forEach(num =>
            finalArr.push(num)
        );

        return finalArr;
    };

    /**
     * 正式開始進行 "合併排序"
     */
    const _mergeSort = arr => {
        const length = arr.length;
        // 只有一項不需要排序
        if (length < 2) return arr;
        // 找中間點
        const medianIndex = Math.floor(length / 2);
        // 取第一項到中間點，不含中間點
        const arr1 = arr.slice(0, medianIndex);
        // 取中間點到最後
        const arr2 = arr.slice(medianIndex);
        return getMergedSortedArr(
            _mergeSort(arr1),
            _mergeSort(arr2)
        );
    };

    return _mergeSort(arr);
};

console.log('--------');
console.log('unsorted arr', testArr);
console.log('mergeSort arr', mergeSort(testArr));
console.log('--------');
```

### 快速排序法

1. 取一個數為 pivot，
2. 然後將 arr 切分成 leftArr(<pivot), pivot, rightArr(>pivot)
3. 對 leftArr, rightArrr 兩個子集重複進行第一步與第二步，直到子集 arr 中只有一個數

```javascript
const quickSort = arr => {
    arr = [...arr];

    if (arr.length < 2) return arr;

    // 一律假設第一個數是 pivot
    const pivot = arr.splice(0, 1)[0];

    // 除了 pivot 外的每一項分成兩堆，
    // 大於 pivot 跟小於 pivot
    const leftArr = [];
    const rightArr = [];
    arr.forEach(num => {
        if (num > pivot) {
            rightArr.push(num);
        } else {
            leftArr.push(num);
        }
    });

    // 遞迴
    return [
        ...quickSort(leftArr),
        pivot,
        ...quickSort(rightArr),
    ];
};

console.log('--------');
console.log('unsorted arr', testArr);
console.log('quickSort arr', quickSort(testArr));
console.log('--------');

```



## References

http://huli.logdown.com/posts/2223627-review-the-classical-sort-algorithm-with-javascript

https://visualgo.net/en/sorting

https://hiskio.com/courses/127